using midi;
using ui;
using set;

let pattern_ch_ref = ref 0;
pattern_ch         = get pattern_ch_ref;
let chord_ch_ref   = ref 1;
chord_ch           = get chord_ch_ref;
let output_ch_ref  = ref 0;
output_ch          = get output_ch_ref;

pattern_ch_control = ui::Slider "Pattern Channel" (pattern_ch+1) 1 16 (\v-> put pattern_ch_ref (v-1));
chord_ch_control = ui::Slider "Chord Channel" (chord_ch+1) 1 16 (\v-> put chord_ch_ref (v-1));
output_ch_control = ui::Slider "Output Channel" (output_ch+1) 1 16 (\v-> put output_ch_ref (v-1));

let chordref = ref (set []);
chord = list (get chordref);
chord_add n::int = put chordref (insert (get chordref) n);
chord_rm  n::int = put chordref (delete (get chordref) n);

create_ui = [pattern_ch_control, chord_ch_control, output_ch_control];

process_midi_buffer buf::midi_buffer_t = // buf is on the form [(event, position)...]
  result with

    split buf::midi_buffer_t =
      foldl spl [[],[],[]] buf with
        spl [notes_on_off, chord_notes_on_off, pass_through] ep = 
          [notes_on_off + [ep], chord_notes_on_off, pass_through] if (is_note_on_or_off ep) && (get_channel ep) == pattern_ch;
        spl [notes_on_off, chord_notes_on_off, pass_through] ep = 
          [notes_on_off, chord_notes_on_off + [ep], pass_through] if (is_note_on_or_off ep) && (get_channel ep) == chord_ch;
        spl [notes_on_off, chord_notes_on_off, pass_through] ep = 
          [notes_on_off, chord_notes_on_off, pass_through + [ep]] otherwise;
      end;

    result = 
        processed + pass_through when
             [notes_on_off, chord_notes_on_off, pass_through] = split buf;
             processed = (update_chord chord_notes_on_off) + (catmap mk_notes notes_on_off);
        end;
  end;

update_chord buf::midi_buffer_t =
  result with 
    add_or_remove ep::event_position_t = 
      if is_note_on ep then
        chord_add (get_note ep) $$ []
      else  // in case a note is removed from a chord, turn it off on all octaves of the output channel
        chord_rm (get_note ep) $$ note_off_on_all_octaves ep;
    result = catmap add_or_remove buf;
  end;

note_off_on_all_octaves ep::event_position_t =
  map (\octave -> note_off_tuple output_ch ((octave * 12) + ((get_note ep) mod 12)) (position ep))(0..9);

mk_notes ep::event_position_t =
  result with
    on = is_note_on ep;
    off = is_note_off ep;
    n = get_note ep;
    c = output_ch; //get_channel ep;
    v = if on then get_velocity ep else 0;
    p = position ep;
    distance_from_base = n mod 12;
    octave = n div 12;
    transpose = octave * 12;
    chord_note d =  (chord!(d-1)) + transpose;
    process =
       case distance_from_base of
        0 = chord_on c v transpose p if on;
        0 = chord_off c transpose p if off;
        d = [note_on_tuple c (chord_note d) v p] if on && d <= #chord;
        d = [note_off_tuple c (chord_note d) p]  if off && d <= #chord;
        _ = [];
      end;

    result = if (#chord) == 0 then [all_notes_off c p] else process;
  end;

chord_on channel::int velocity::int transpose::int position::int =
  map (\n -> note_on_tuple channel (n+transpose) velocity position) chord;

chord_off channel::int transpose::int position::int =
  map (\n -> note_off_tuple channel (n+transpose) position) chord;





